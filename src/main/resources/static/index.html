<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>实时多用户绘画板</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; }
        canvas { border: 1px solid #000; }
        #toolbar { margin-bottom: 10px; }
    </style>
</head>
<body>
<h2>实时多用户绘画板</h2>
<div id="toolbar">
    <label for="colorPicker">颜色选择：</label>
    <input type="color" id="colorPicker" value="#000000">
    <label for="brushSize">画笔大小：</label>
    <input type="range" id="brushSize" min="1" max="20" value="5">
    <button onclick="undo()">撤销</button>
    <button onclick="redo()">重做</button>
</div>
<canvas id="canvas" width="800" height="600"></canvas>
<script src="https://cdn.jsdelivr.net/npm/sockjs-client/dist/sockjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/stompjs/lib/stomp.min.js"></script>
<script>

    function getQueryVariable(variable) {
        var query = window.location.search.substring(1);
        var vars = query.split('&');
        for (var i = 0; i < vars.length; i++) {
            var pair = vars[i].split('=');
            if (decodeURIComponent(pair[0]) === variable) {
                return decodeURIComponent(pair[1]);
            }
        }
        return null;
    }

    const boardId = getQueryVariable('boardId');
    const canvas = document.getElementById('canvas');
    const context = canvas.getContext('2d');
    let current = { color: document.getElementById('colorPicker').value, size: document.getElementById('brushSize').value };
    let drawing = false;
    let path = [];  // Store the path drawn by the user
    const endpoint = `/paint`;
    // const endpoint = `/api/board/${boardId}/ws`;
    const stompClient = Stomp.over(new SockJS(endpoint));
    const undoStack = [];
    const redoStack = [];

    // stompClient.connect({}, () => {
    //     stompClient.subscribe('/topic/paint', (message) => {
    //         const data = JSON.parse(message.body);
    //         drawOnCanvas(data.x0, data.y0, data.x1, data.y1, data.color, data.size, false);
    //     });
    // });

    stompClient.connect({}, () => {
        stompClient.subscribe('/topic/paint', (message) => {
            const actions = JSON.parse(message.body); // 解析成绘图动作数组
            actions.forEach(action => {
                arrDrawOnCanvas(action.x0, action.y0, action.x1, action.y1, action.color, action.size, false);
            });
        });
    });


    function arrDrawOnCanvas(x0, y0, x1, y1, color, size, save = true) {
        context.beginPath();
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.strokeStyle = color;
        context.lineWidth = size;
        context.stroke();
        context.closePath();
        if (save) {
            undoStack.push({x0, y0, x1, y1, color, size});
            redoStack.length = 0; // 重置重做栈
        }
    }

    function drawOnCanvas(x0, y0, x1, y1, color, size, save = true) {
        context.beginPath();
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.strokeStyle = color;
        context.lineWidth = size;
        context.stroke();
        context.closePath();
        if (save) {
            undoStack.push({x0, y0, x1, y1, color, size});
            redoStack.length = 0;
        }
    }

    function drawLine(x0, y0, x1, y1) {
        drawOnCanvas(x0, y0, x1, y1, current.color, current.size);
        path.push({x0, y0, x1, y1, color: current.color, size: current.size});
    }

    function sendPath() {
        if (path.length > 0) {
            stompClient.send("/app/draw", {}, JSON.stringify(path));
            path = [];
        }
    }

    canvas.addEventListener('mousedown', (e) => {
        drawing = true;
        current.x = e.offsetX;
        current.y = e.offsetY;
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!drawing) return;
        drawLine(current.x, current.y, e.offsetX, e.offsetY);
        current.x = e.offsetX;
        current.y = e.offsetY;
    });

    canvas.addEventListener('mouseup', () => {
        drawing = false;
        sendPath();  // Send the entire path on mouse up
    });

    canvas.addEventListener('mouseout', () => {
        if (drawing) {
            drawing = false;
            sendPath();  // Ensure the path is sent even if the user leaves the canvas
        }
    });

    document.getElementById('colorPicker').addEventListener('change', (e) => {
        current.color = e.target.value;
    });

    document.getElementById('brushSize').addEventListener('change', (e) => {
        current.size = e.target.value;
    });
</script>
</body>
</html>
